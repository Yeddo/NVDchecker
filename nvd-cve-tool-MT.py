'''
# ***********************************************************************
# AUTHOR = Jason Bisnette
# COPYRIGHT = 
# LICENSE = 
# VERSION = 1.0
# EMAIL = jason.bisnette@gmail.com
# DESCRIPTION = MULTI-THREADED VERSION This script takes a list of opkg 
# packages and checks each package and version on the national vulerability
# database site and creates an excel document with the results.
# USAGE = python nvd-cve-tool-MT.py -k 9e0a566b-c66d-487b-bc98-0b64773224ff -b "Opkg CVE's for WindRiver Linux 4.19.128 PIT-EDGE" -i fixed_output_file.txt -o cve.xlsx
# FILENAME = nvd-cve-tool-MT.py
# ***********************************************************************
TODO:
- RPM Parser for redhat
- RPM Parser for fedora
- RPM Parser for windriver?
- Auto Detect and parse input file for kernel/OS type?
'''

# DOESN'T WORK. THE API STARTS TO TIME OUT EVEN WITH ONLY 2 THREADS ...

# Imports
import requests # GET request
import json     # Json library
import openpyxl # Excel libraries
from openpyxl.workbook import Workbook
from openpyxl.styles import Font
from openpyxl.styles import Alignment
from openpyxl.utils import get_column_letter
import argparse # Parses arguments
import sys      # For slow printing function
import time     # Time to sleep for queries without API key
from progress.bar import IncrementalBar  # Status bar
import re       # For regex
import os       # For path
import urllib.request   # For URL connection
import concurrent.futures # For multi-threading
import datetime # For timer

# FUNCTIONS

# Function to check internet access.
def connect(host='https://nvd.nist.gov/'):
    try:
        urllib.request.urlopen(host) #Python 3.x
        return True
    except:
        return False

# Function to print text slowly. Fancy!?!
def delay_print(s):
    for c in s:
        # Two tricks here ...
        sys.stdout.write(c) # 1. you need to use a stream to get everything in the right place.
        sys.stdout.flush() # 2. you also need to flush the stream buffer.
        time.sleep(0.05) # Adjust to speed up/slow down.

# OPKG format fixer.
def opkg_parser(input_file_path, output_file_path):
    # Define the regex pattern(s).
    pattern = r"-r[0-9].*$" # remove anything with -r# off the end and replace with blank.
    pattern2 = r"~r.*"      # remove anything with ~r off the end and replace with blank.
    pattern3 = r"-cip.*"    # removes all occurances of -cip and replace with blank.
    pattern4 = r'([a-zA-Z0-9-]+)-(?!.*-)(\d+\.\d+\.\d+)' # fixes yocto kernel package output.
    pattern5 = r"\+.*"      # remove anything with a + off the end and replace with blank.

    # Open the input file for reading and output file for writing.
    with open(input_file_path, 'r') as input_file, open(output_file_path, 'w') as output_file:
        # Iterate over each line in the input file
        for line in input_file:
            # sub() replaces every occurrence of a pattern with a string or the result of a function. 
            output_string = re.sub(pattern, "", line)
            output_string = re.sub(pattern2, "", output_string)
            output_string = re.sub(pattern5, "", output_string)
            # Write results to output_file.
            output_file.write(output_string)
    # Pattern3 and Pattern4 will not work correctly when included in the above so, lets do is seperately ...
    # Open the output_file as read/write
    with open(output_file_path, 'r+') as file:
        # Read the existing contents of the file into memory
        contents = file.read()
        # Modify the contents of the file in memory
        contents = re.sub(pattern3, "", contents)
        contents = re.sub(pattern4, r'\1 - \2', contents)
        # Move the file pointer to the beginning of the file
        file.seek(0)
        # Write the modified contents back out to the file
        file.write(contents)
        # Truncate any remaining content from the file
        file.truncate()
    print(f"Parsing complete! File located: {output_file_path}\n")
# End opkg_parser

# Define a function to process a single package
def process_package(package):
    # Code to process a single package goes here
    bar.next()
    #m = re.search(r'\d+$', package)
    #if m:
    # This checks to make sure the line has a hyphen surrounded by spaces in it.
    if ' - ' in package:
        package_name, package_version = package.split(" - ")
    # If there isn't a hyphen surrounded by spaces append the package name and error to excel spreadsheet and move on.
    else:
        ws.append([package, '', '', '', '', "Formatting incorrect!"])
    
    # Check if noKey is True/False and sets appropriate url variable.
    if noKey:
        # See https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nistir7695.pdf for full documentation of the API. Document # NISTIR7695
        url = f"https://services.nvd.nist.gov/rest/json/cves/1.0?cpeMatchString=cpe:2.3:a:*:{package_name}:{package_version}"
        
        # Suggested pause per API documentation. 6 secs between query with no API key otherwise the NVD API will disallow you and you will get 404 errors.
        time.sleep(6)
    else:
        # See https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nistir7695.pdf for full documentation of the API. Document # NISTIR7695
        url = f"https://services.nvd.nist.gov/rest/json/cves/1.0?apikey={apiKey}&cpeMatchString=cpe:2.3:a:*:{package_name}:{package_version}"
    
    # Query NVD API
    response = requests.get(url)
    # Tests if site responded.
    if response.status_code == 200: 
        # Recieve json data from NVD.
        cve_items = response.json()["result"]["CVE_Items"]
        #print(cve_items[0])
        #print('\n')
        #print(package_name, package_version)
        if cve_items: # Tests if there were results
        # Parse jason. You can change this to add/remove data as it got the entire response from line above.
            for cve_item in cve_items:
                #print(f'\n{package_name}-{package_version}')
                # Store CVE-ID
                cve_id = cve_item["cve"]["CVE_data_meta"]["ID"]
                # Store CWE-ID. Not using this yet.
                cwe_id = cve_item["cve"]["problemtype"]["problemtype_data"][0]["description"][0]["value"]
                # Handle error where baseMetricV3 doesn't exist just skip it, get the rest of the info and append to excel.
                if 'baseMetricV3' not in cve_item["impact"]:
                    # Store date published
                    published_date = cve_item["publishedDate"]
                    # Store description
                    description = cve_item["cve"]["description"]["description_data"][0]["value"]
                    # Write to file.
                    ws.append([package_name, package_version, cve_id, 'Not Provided', published_date, description])
                    # Progress bar counter
                    #bar.next()
                    continue # Loop to next item in list.
                # Store CVSS score
                cvss_score = cve_item["impact"]["baseMetricV3"]["cvssV3"]["baseScore"]
                # Store date published
                published_date = cve_item["publishedDate"]
                # Store description
                description = cve_item["cve"]["description"]["description_data"][0]["value"]
                # Write to file.
                ws.append([package_name, package_version, cve_id, cvss_score, published_date, description])
        else:
            #print(f'\n{package_name}-{package_version}')
            ws.append([package_name, package_version, "None Found"])
    else:
        print(f" Error querying NVD API for {package_name} {package_version}: {response.status_code} {response.reason}")
        # Write to file.
        ws.append([package_name, package_version, response.status_code, response.reason])

# END FUNCTIONS

# BEGIN

print ("""
    .----.   @   @
   / .-"-.`.  \v/
   | | '\ \ \_/ )
 ,-\ `-.' /.'  /
'---`----'----'
""")

delay_print('Snail CVE Lookup tool ... ¯\_(ツ)_/¯')
print ('\n')

# Parse out all of the command line arguments
parser = argparse.ArgumentParser(description="Try to look up CVE's from the National Vulnerability Database (NVD) for a file listing of packages")
parser.add_argument('-i', '--infile', help='Input File', required=True)
parser.add_argument('-k', '--nvdKey', help='NVD API Key', required=False)
parser.add_argument('-o', '--outfile', help='The file to write results (needs to be writable for current user)', required=True)
parser.add_argument('-b', '--banner', help='This will display as the top header of your excel document above the column headers. ', required=False, default='OS/Kernel/Version Unknown')
parser.add_argument('-os', '--os_kernel', help='This is for the kernel/OS. Example: RedHat, Fedora, WindRiver, Debian, Ubuntu, etc. Not everything is supported. Use at your own risk!', required=False)
parser.add_argument('-p', '--parser', help='This will parse a package listing. Right now the only option is opkg. Run the following to collect packages in the proper format before feeding it to this parser.', required=False)
args = parser.parse_args()

# sets infile argument and checks if file exists.
inputFile = args.infile
if not os.path.exists(inputFile):
    print(f'ERROR: Input file does not exit {inputFile}')
    exit()

# sets outfile argument
outputFile = args.outfile

if args.parser:
    delay_print('Running file parser only!')
    print('\n')
    opkg_parser(inputFile, outputFile)
    exit()

# Test internect connection.
if not connect():
    print('You have no internet! Please connect to the internet for this script to work.\n')
    exit()

# Reads nvdKey argument and sets noKey bool.
if args.nvdKey:
    apiKey = args.nvdKey
    noKey = False
else:
    print('No NVD API key supplied. The queries will be restricted to 1 every 6 seconds.'
    'This is probably going to be very slow for you depending on how many packages there are.\n\n'
    'You should get an API key from NVD: https://nvd.nist.gov/developers/request-an-api-key \n')
    noKey = True

# Variable for printing this in the excel document on the top.   
if args.banner:
    bannerInfo = args.banner

print(f'Opening and reading the file {inputFile}...\n')

# Open the file and read list of OPKG packages
with open(inputFile, "r") as f:
    opkg_packages = [line.strip() for line in f.readlines()]

print(f"Read {len(opkg_packages)} packages from the input file. NOTE: This does not mean there will be only this many in the output as there may be more than one CVE associated with each package.\n")

# Initailze progress bar and set the threshold for the number of lines in the file.
bar = IncrementalBar('Processing Packages: ', max = len(opkg_packages))

# Set up Excel spreadsheet and write header row.
wb = openpyxl.Workbook()
ws = wb.active
ws.merge_cells('A1:F2')
cell = ws.cell(row=1, column=1)  
cell.value = bannerInfo  
cell.alignment = Alignment(horizontal='center', vertical='center')  
ws['A1'].font = Font(bold=True,size=18)
# This moves the row down because for some reason the merge doesn't get seen as 2 rows, only 1 but the next appended row ends up blank if this isn't here. ¯\_(ツ)_/¯
ws.append([""])
# This needs to be here before changing font style otherwise it'll "append" below first row. Or you can specify where every cell goes that the column headers go in individually (ws['A1'] = "Package Version").
ws.append(["Package Name", "Package Version", "CVE ID", "CVSS Score", "Published Date", "Description"])
# Bold header row.
ws['A3'].font = Font(bold=True)
ws['B3'].font = Font(bold=True)
ws['C3'].font = Font(bold=True)
ws['D3'].font = Font(bold=True)
ws['E3'].font = Font(bold=True)
ws['F3'].font = Font(bold=True)
# Center header row except for last row 'F'
ws['A3'].alignment = Alignment(horizontal='center')
ws['B3'].alignment = Alignment(horizontal='center')
ws['C3'].alignment = Alignment(horizontal='center')
ws['D3'].alignment = Alignment(horizontal='center')
ws['E3'].alignment = Alignment(horizontal='center')
# Resize all the columns
ws.column_dimensions['A'].width = 30
ws.column_dimensions['B'].width = 16
ws.column_dimensions['C'].width = 16
ws.column_dimensions['D'].width = 11
ws.column_dimensions['E'].width = 18
ws.column_dimensions['F'].width = 20

# Start the timer
#start_time = time.time()
start_time = datetime.datetime.now()

# Loop through OPKG packages and query NVD API for each
# Create a ThreadPoolExecutor with 5 worker threads
with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
    # Submit a task for each package to the executor
    futures = [executor.submit(process_package, package) for package in opkg_packages]

    # Wait for all tasks to complete
    concurrent.futures.wait(futures)

bar.finish() # Progress finished
print('All done!\n')

# Stop the timer
#end_time = time.time()
end_time = datetime.datetime.now()
# Calculate the elapsed time
elapsed_time = end_time - start_time
# Convert the elapsed time to minutes and seconds
minutes, seconds = divmod(elapsed_time.total_seconds(), 60)
# Print the elapsed time
print("Elapsed time: {:02d}:{:02d}".format(int(minutes), int(seconds)))

# Change column widths. You can't do ranges or entire columns with openpyxl, so loop.
for row in ws[1:ws.max_row]:
    cell = row[0]     # 
    cell.alignment = Alignment(horizontal='center')
for row in ws[1:ws.max_row]:
    cell = row[1]     # 
    cell.alignment = Alignment(horizontal='center')
for row in ws[1:ws.max_row]: 
    cell = row[3]     # 
    cell.alignment = Alignment(horizontal='center')

# Save Excel spreadsheet
wb.save(outputFile)
print(f"File written to : {outputFile}\n")
